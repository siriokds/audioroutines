#include "FCp.h"
#include "Paula.h"

static	char	LibInfo[] = 
	"****************"
	"FCLIB v1.02 "
	"- Future Composer 1.3 / 1.4 replayer library for PocketPC "
	"by SiRioKD"
	"****************";


static	KInstr	SNDinfo[128];
static	KChan	VXdata[4];

static	SBYTE	SEQinfo[256*16];	//   4Kb
static	SBYTE	PATinfo[256*64];	//  16Kb
static	SBYTE	VOLinfo[256*64];	//  16Kb
static	SBYTE	FRQinfo[256*64];	//  16Kb
static	SBYTE	SMPinfo[SMP_BUFSIZE];	//  80Kb

//-- Module Variables --
static	BOOL	Opened;
static	BOOL	Playing;

static	BOOL	FC13mode;

static	SBYTE	REPcnt;
static	SBYTE	REPspd;

static	SLONG	SEQendp;
static	SLONG	SEQoffs;
static	SLONG	SEQnext;

static	SLONG	SEQnum;
static	SLONG	PATnum;
static	SLONG	VOLnum;
static	SLONG	FRQnum;
//----------------------



static	SWORD	PERIODS[] = 
{
	 0x06b0,0x0650,0x05f4,0x05a0,0x054c,0x0500,0x04b8,0x0474,0x0434,0x03f8,0x03c0,0x038a
	,0x0358,0x0328,0x02fa,0x02d0,0x02a6,0x0280,0x025c,0x023a,0x021a,0x01fc,0x01e0,0x01c5
	,0x01ac,0x0194,0x017d,0x0168,0x0153,0x0140,0x012e,0x011d,0x010d,0x00fe,0x00f0,0x00e2
	,0x00d6,0x00ca,0x00be,0x00b4,0x00aa,0x00a0,0x0097,0x008f,0x0087,0x007f,0x0078,0x0071
	,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071

	,0x0d60,0x0ca0,0x0be8,0x0b40,0x0a98,0x0a00,0x0970,0x08e8,0x0868,0x07f0,0x0780,0x0714
	,0x1ac0,0x1940,0x17d0,0x1680,0x1530,0x1400,0x12e0,0x11d0,0x10d0,0x0fe0,0x0f00,0x0e28
	,0x06b0,0x0650,0x05f4,0x05a0,0x054c,0x0500,0x04b8,0x0474,0x0434,0x03f8,0x03c0,0x038a
	,0x0358,0x0328,0x02fa,0x02d0,0x02a6,0x0280,0x025c,0x023a,0x021a,0x01fc,0x01e0,0x01c5
	,0x01ac,0x0194,0x017d,0x0168,0x0153,0x0140,0x012e,0x011d,0x010d,0x00fe,0x00f0,0x00e2
	,0x00d6,0x00ca,0x00be,0x00b4,0x00aa,0x00a0,0x0097,0x008f,0x0087,0x007f,0x0078,0x0071

	,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071
	,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071,0x0071
};



static	UBYTE	WAVEFORMS_sizes[] = 
{
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x10,0x10,0x08,0x08,0x18
};


static	UBYTE	WAVEFORMS[] = 
{
	 0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0x3f,0x37,0x2f,0x27,0x1f,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0x37,0x2f,0x27,0x1f,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0x2f,0x27,0x1f,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0x27,0x1f,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0x1f,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x17,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x0f,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x07,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0xff,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x0f,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x90,0x17,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x90,0x98,0x1f,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x90,0x98,0xa0,0x27,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x90,0x98,0xa0,0xa8,0x2f,0x37
	,0xc0,0xc0,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8,0x00,0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8
	,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80,0x88,0x90,0x98,0xa0,0xa8,0xb0,0x37
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f,0x7f
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81
	,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f
	,0x80,0x80,0x90,0x98,0xa0,0xa8,0xb0,0xb8,0xc0,0xc8,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8
	,0x00,0x08,0x10,0x18,0x20,0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x7f
	,0x80,0x80,0xa0,0xb0,0xc0,0xd0,0xe0,0xf0,0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x70
	,0x45,0x45,0x79,0x7d,0x7a,0x77,0x70,0x66,0x61,0x58,0x53,0x4d,0x2c,0x20,0x18,0x12
	,0x04,0xdb,0xd3,0xcd,0xc6,0xbc,0xb5,0xae,0xa8,0xa3,0x9d,0x99,0x93,0x8e,0x8b,0x8a
	,0x45,0x45,0x79,0x7d,0x7a,0x77,0x70,0x66,0x5b,0x4b,0x43,0x37,0x2c,0x20,0x18,0x12
	,0x04,0xf8,0xe8,0xdb,0xcf,0xc6,0xbe,0xb0,0xa8,0xa4,0x9e,0x9a,0x95,0x94,0x8d,0x83
	,0x00,0x00,0x40,0x60,0x7f,0x60,0x40,0x20,0x00,0xe0,0xc0,0xa0,0x80,0xa0,0xc0,0xe0
	,0x00,0x00,0x40,0x60,0x7f,0x60,0x40,0x20,0x00,0xe0,0xc0,0xa0,0x80,0xa0,0xc0,0xe0
	,0x80,0x80,0x90,0x98,0xa0,0xa8,0xb0,0xb8,0xc0,0xc8,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8
	,0x00,0x08,0x10,0x18,0x20,0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x7f
	,0x80,0x80,0xa0,0xb0,0xc0,0xd0,0xe0,0xf0,0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x70
};


/*----------------------------------------------------------------------*/
static	SWORD	FC_GET_ASWORD_AT(SBYTE *p)
/*----------------------------------------------------------------------*/
{
SWORD	w1,w2;

		w1 = ((SWORD)p[0]) << 8;
        w2 = ((SWORD)p[1]) & 0xFF;
		return (w1 | w2);
}

/*----------------------------------------------------------------------*/
static	SLONG	FC_GET_ASLONG_AT(SBYTE *p)
/*----------------------------------------------------------------------*/
{
SLONG	w1,w2,w3,w4;

		w1 = (((SLONG)p[0]) << 24) & 0xFF000000;
        w2 = (((SLONG)p[1]) << 16) & 0x00FF0000;
        w3 = (((SLONG)p[2]) << 8 ) & 0x0000FF00;
        w4 = (((SLONG)p[3])      ) & 0x000000FF;

		return (w1 | w2 | w3 | w4);
}



/*----------------------------------------------------------------------*/
void	FCp_Close(void)
/*----------------------------------------------------------------------*/
{
	paulaClose();

	Playing = FALSE;
	Opened = FALSE;
}


/*----------------------------------------------------------------------*/
int	FCp_Open(void)
/*----------------------------------------------------------------------*/
{
	Opened = FALSE;
	Playing = FALSE;

	paulaOpen(FCp_Update, 50);

    ZeroMemory(SNDinfo,sizeof(SNDinfo));
    ZeroMemory(SEQinfo,sizeof(SEQinfo));
    ZeroMemory(PATinfo,sizeof(PATinfo));
    ZeroMemory(VOLinfo,sizeof(VOLinfo));
    ZeroMemory(FRQinfo,sizeof(FRQinfo));

    Opened = TRUE;
	return 0;
}

/*-----------------------------------------------------------------------*/
void	FCp_Start(void)
/*-----------------------------------------------------------------------*/
{
	if (Opened == FALSE) return;
        
	paulaStart();
	
	Playing = TRUE;
}


/*-----------------------------------------------------------------------*/
void	FCp_Stop(void)
/*-----------------------------------------------------------------------*/
{
	if (Opened == FALSE) return;
	
	Playing = FALSE;
}




/*----------------------------------------------------------------------*/
int		FCp_InitFC3(SBYTE *Module)
/*----------------------------------------------------------------------*/
{
SBYTE	*p;
UBYTE	*up;
int		i;
ULONG	Start;
SBYTE	*SMPaddr;
ULONG	SMPlen;

		FC13mode = TRUE;

		SEQnum	= (FC_GET_ASLONG_AT(Module+ 4) / 13) & 255;
		PATnum	= (FC_GET_ASLONG_AT(Module+12) / 64) & 255;
		FRQnum	= (FC_GET_ASLONG_AT(Module+20) / 64) & 255;
		VOLnum	= (FC_GET_ASLONG_AT(Module+28) / 64) & 255;

		SEQendp	= SEQnum * 16;

        VOLinfo[sizeof(VOLinfo) - 64] = (SBYTE) 0xE1;
        FRQinfo[sizeof(FRQinfo) - 64] = (SBYTE) 0xE1;

        p = Module + 100;
		for (i = 0; i < SEQnum; i++)
			CopyMemory(SEQinfo + (i * 16), p + (i * 13), 13);

		p = Module + FC_GET_ASLONG_AT(Module+8);
       	CopyMemory(PATinfo, p, PATnum * 64);

		p = Module + FC_GET_ASLONG_AT(Module+16);
       	CopyMemory(FRQinfo, p, FRQnum * 64);

		p = Module + FC_GET_ASLONG_AT(Module+24);
       	CopyMemory(VOLinfo, p, VOLnum * 64);

		SMPaddr	= Module + FC_GET_ASLONG_AT(Module+32);


//--------------------------------------------------------
// Load Samples

   		Start = 0;

		p = Module + 40;
		for (i = 0; i < 10; i++, p += 6)
		{
			SNDinfo[i].Start  = Start;
			SNDinfo[i].Len    = FC_GET_ASWORD_AT(p+0);
			SNDinfo[i].RepSta = FC_GET_ASWORD_AT(p+2);
			SNDinfo[i].RepLen = FC_GET_ASWORD_AT(p+4);
//			SNDinfo[i].RepLen = 1;

            if (SNDinfo[i].Len > 1)
				Start += ((SNDinfo[i].Len * 2) + 2);
		}

//		if (Start > SMP_BUFSIZE) Start = SMP_BUFSIZE;


        SMPlen = Start;

//--------------------------------------------------------
// Load Waves

		up = &WAVEFORMS_sizes[0];
		for (i = 10; i < 47+10; i++, up++)
		{
			SNDinfo[i].Start  = Start;
			SNDinfo[i].Len    = (UWORD)*up;
			SNDinfo[i].RepSta = 0;
			SNDinfo[i].RepLen = SNDinfo[i].Len;
			Start += (SNDinfo[i].Len * 2);
		}



		CopyMemory(SMPinfo,		  SMPaddr,SMPlen);
		CopyMemory(SMPinfo+SMPlen,WAVEFORMS,1344);



//--------------------------------------------------------
// get replay speed, if 0 use default value (3);

		REPspd = 3;	REPcnt = 1;
		if (SEQinfo[12]) REPspd = SEQinfo[12];

		SEQoffs = SEQendp;

		ZeroMemory(VXdata, sizeof(VXdata));

		for (i = 0; i < 4; i++)
		{
			VXdata[i].VoiceN = i;
			VXdata[i].VolTspd = 1;
			VXdata[i].VolTcnt = 1;

			VXdata[i].PatPtr = PATinfo + (SEQinfo[0] * 64);
			VXdata[i].PatOfs = 64;
			VXdata[i].NoteTR = SEQinfo[1];	// Transpose value
			VXdata[i].SampTR = SEQinfo[2];	// SoundTranspose value

			VXdata[i].VolPtr = VOLinfo + sizeof(VOLinfo) - 64;
			VXdata[i].FrqPtr = FRQinfo + sizeof(FRQinfo) - 64;
		}

		VXdata[0].ON = TRUE;
		VXdata[1].ON = TRUE;
		VXdata[2].ON = TRUE;
		VXdata[3].ON = TRUE;

		return 0;
}







/*----------------------------------------------------------------------*/
int		FCp_InitFC4(SBYTE *Module)
/*----------------------------------------------------------------------*/
{
SBYTE	*p;
UBYTE	*up;
int		i;
ULONG	Start;
SBYTE	*SMPaddr;
ULONG	SMPlen;
SBYTE	*WAVaddr;
ULONG	WAVlen;
UWORD	val;

		FC13mode = FALSE;

		SEQnum	= (FC_GET_ASLONG_AT(Module+ 4) / 13);
		PATnum	= (FC_GET_ASLONG_AT(Module+12) / 64) & 255;
		FRQnum	= (FC_GET_ASLONG_AT(Module+20) / 64) & 255;
		VOLnum	= (FC_GET_ASLONG_AT(Module+28) / 64) & 255;

		SEQendp	= SEQnum * 16;

        VOLinfo[sizeof(VOLinfo) - 64] = (SBYTE) 0xE1;
        FRQinfo[sizeof(FRQinfo) - 64] = (SBYTE) 0xE1;

        p = Module + 180;
		for (i = 0; i < SEQnum; i++)
			CopyMemory(SEQinfo + (i * 16), p + (i * 13), 13);

		p = Module + FC_GET_ASLONG_AT(Module+8);
       	CopyMemory(PATinfo, p, PATnum * 64);

		p = Module + FC_GET_ASLONG_AT(Module+16);
       	CopyMemory(FRQinfo, p, FRQnum * 64);

		p = Module + FC_GET_ASLONG_AT(Module+24);
       	CopyMemory(VOLinfo, p, VOLnum * 64);

		SMPaddr	= Module + FC_GET_ASLONG_AT(Module+32);
		WAVaddr	= Module + FC_GET_ASLONG_AT(Module+36);


//--------------------------------------------------------
// Load Samples

   		Start = 0;

		p = Module + 40;
		for (i = 0; i < 10; i++, p += 6)
		{
			SNDinfo[i].Start  = Start;
			SNDinfo[i].Len    = FC_GET_ASWORD_AT(p+0);
			SNDinfo[i].RepSta = FC_GET_ASWORD_AT(p+2);
			SNDinfo[i].RepLen = FC_GET_ASWORD_AT(p+4);
//			SNDinfo[i].RepLen = 1;

            if (SNDinfo[i].Len > 1)
				Start += ((SNDinfo[i].Len * 2) + 2);
		}

//		if (Start > SMP_BUFSIZE) Start = SMP_BUFSIZE;


        SMPlen = Start;

//--------------------------------------------------------
// Load Waves

		up = (UBYTE*)Module + 100;
		for (i = 10; i < 90; i++, up++)
		{
			SNDinfo[i].Start  = Start;
			val = *up;
			if (val > 0x80) val = 0x80;
			SNDinfo[i].Len    = (UWORD)val;
			SNDinfo[i].RepSta = 0;
			SNDinfo[i].RepLen = SNDinfo[i].Len;

            if (SNDinfo[i].Len > 1)
				Start += (SNDinfo[i].Len * 2);
		}



        WAVlen = Start - SMPlen;


		if (Start > SMP_BUFSIZE) Start = SMP_BUFSIZE;
		CopyMemory(SMPinfo,SMPaddr,Start);


//		CopyMemory(SMPinfo,SMPaddr,SMPlen);
//		CopyMemory(SMPinfo+SMPlen,WAVaddr,WAVlen);



//--------------------------------------------------------
// get replay speed, if 0 use default value (3);

		REPspd = 3;	REPcnt = 1;
		if (SEQinfo[12]) REPspd = SEQinfo[12];

		SEQoffs = SEQendp;

		ZeroMemory(VXdata, sizeof(VXdata));

		for (i = 0; i < 4; i++)
		{
			VXdata[i].VoiceN = i;
			VXdata[i].VolTspd = 1;
			VXdata[i].VolTcnt = 1;

			VXdata[i].PatPtr = PATinfo + (SEQinfo[0] * 64);
			VXdata[i].PatOfs = 64;
			VXdata[i].NoteTR = SEQinfo[1];	// Transpose value
			VXdata[i].SampTR = SEQinfo[2];	// SoundTranspose value

			VXdata[i].VolPtr = VOLinfo + sizeof(VOLinfo) - 64;
			VXdata[i].FrqPtr = FRQinfo + sizeof(FRQinfo) - 64;
		}

		VXdata[0].ON = TRUE;
		VXdata[1].ON = TRUE;
		VXdata[2].ON = TRUE;
		VXdata[3].ON = TRUE;

		return 0;
}





/*----------------------------------------------------------------------*/
int	FCp_InitModule(SBYTE *Module)
/*----------------------------------------------------------------------*/
{
ULONG	*p = (ULONG*)Module;

	if (*p == 0x34314346) 
		return FCp_InitFC4(Module);	// Check for "FC14"
	else
	if (*p == 0x444F4D53) 
		return FCp_InitFC3(Module); // Check for "SMOD"
	
	return 1;
}



/*----------------------------------------------------------------------*/
static	void	NewNote(int VocNum)
/*----------------------------------------------------------------------*/
{
SBYTE	*p, note, info, temp;
KChan	*chn = &VXdata[VocNum];


		if (chn->PatOfs >= 64) goto patend;

		p = chn->PatPtr + chn->PatOfs;
        if (p[0] != 0x49) goto samepat;

//--------------------------------------------------------------------
patend:
		chn->PatOfs = 0;

		SEQnext++;

        if (SEQnext > 3)
        {
	        SEQnext = 0;
			SEQoffs += 16;

			if (SEQoffs >= SEQendp) SEQoffs = 0;
			if (SEQoffs >= sizeof(SEQinfo)) SEQoffs = 0;

			if (SEQinfo[SEQoffs+12])			// Get replay speed
            	REPspd = REPcnt = SEQinfo[SEQoffs+12];
		}

       	p = SEQinfo + SEQoffs + (VocNum * 3);
		chn->PatPtr = PATinfo + (p[0] * 64);	// Pattern to play
		chn->NoteTR = p[1];						// PatternTranspose
		chn->SampTR = p[2];						// SoundTranspose

//--------------------------------------------------------------------
samepat:

		p = chn->PatPtr + chn->PatOfs;

		info = p[1];	// Get info byte #1 (bl)
		note = p[0];	// Get note			(al)
		if (note) goto ww1;
		if (!(info &= 0xC0)) goto noport;
		goto ww11;
ww1:
		chn->Period = 0;
ww11:
		chn->PortaV = 0;
		if (!(info & 0x80)) goto noport;
		chn->PortaV = p[3];
noport:
		if (!(note &= 0x7F)) goto nextnote;
		chn->Note = note;
		chn->Info = info = p[1];

        paulaStopVoice(VocNum);

		info = (info & 0x3F);
		info += chn->SampTR;

		chn->VolOfs = 0;
		chn->VolSus = 0;
		chn->FrqOfs = 0;
		chn->FrqSus = 0;


		if (info >= VOLnum)
		{
			chn->VolTspd = 0;
			chn->VolTcnt = 0;

			chn->VibSpd = 0;
			chn->VibXOR = 0;
			chn->VibAmp = 0;
			chn->VibDel = 0;

			chn->VolPtr = VOLinfo + sizeof(VOLinfo) - 64;
			chn->FrqPtr = FRQinfo + sizeof(FRQinfo) - 64;
		}
        else
        {

			p = VOLinfo + (info * 64);

			chn->VolTcnt = chn->VolTspd = p[0];

			temp = p[1];

			//Control #2
			if (temp >= FRQnum) temp = FRQnum-1;

			chn->VibSpd = p[2];
			chn->VibXOR = 0x40;
			chn->VibAmp = chn->VibAmpC = p[3];
			chn->VibDel = p[4];

			p += 5;

			chn->VolPtr = p;
			chn->FrqPtr = FRQinfo + (temp * 64);

    	}

nextnote:
		chn->PatOfs += 2;
}






/*-----------------------------------------------------------------------*/
static	void	Effects(int VocNum)
/*-----------------------------------------------------------------------*/
{
UBYTE	val;
SBYTE	*p, tmp;
SBYTE   tmp1;
SLONG	TabOffset;
SWORD	Period;

KChan	*chn = &VXdata[VocNum];


//<<<<<<<<<<<<<<<<<<<<<<<<<<
// FREQUENCY EFFECTS
//<<<<<<<<<<<<<<<<<<<<<<<<<<
testsustain:
	if (chn->FrqSus == 0) goto sustzero;
	chn->FrqSus--;
	goto VOLUfx;
sustzero:
	p = chn->FrqPtr + chn->FrqOfs;
testeffects:
	val = p[0];
	if (val == 0xE1) goto VOLUfx;

	if (val != 0xE0) goto testnewsound;	// E0 = loop to point of FRQtable

	chn->FrqOfs = (SLONG)(p[1] & 0x3F);
	p = chn->FrqPtr + chn->FrqOfs;
	val = p[0];

testnewsound:
	if (val != 0xE2) goto testE4;		// E2 = set waveform (kick!)

	val = chn->SamplN = p[1] & 0x3F;

   	paulaStopVoice(VocNum);

	paulaSetSamplePos(VocNum, SMPinfo + SNDinfo[val].Start);
	paulaSetSampleLen(VocNum, SNDinfo[val].Len);

	paulaPlayVoice(VocNum);

	paulaSetSamplePos(VocNum, SMPinfo + SNDinfo[val].Start + SNDinfo[val].RepSta);
	paulaSetSampleLen(VocNum, SNDinfo[val].RepLen);


	chn->VolOfs = 0;
	chn->VolTcnt = 1;
	chn->FrqOfs += 2;
	goto transpose;

testE4:
	if (val != 0xE4) goto testE9;		// E4 = change waveform (no kick!)

	val = chn->SamplN = p[1] & 0x3F;

    paulaSetSamplePos(VocNum, SMPinfo + SNDinfo[val].Start);
    paulaSetSampleLen(VocNum, SNDinfo[val].Len);

	chn->FrqOfs += 2;
	goto transpose;

testE9:
	if (val != 0xE9) goto testpatjmp;

	paulaStopVoice(VocNum);

//	if (SNDinfo[val].Start != 0x504D5353) goto nossmp;	// Check for "SSMP"

	// Sample pack "SSMP" Not implemented!!!

//nossmp:
	chn->FrqOfs += 3;

testpatjmp:
	if (val != 0xE7) goto testpitchbend;
	chn->FrqOfs = 0;
	p = chn->FrqPtr = FRQinfo + (p[1] * 64);
	goto testeffects;

testpitchbend:
	if (val != 0xEA) goto testnewsustain;
	chn->PBend  = p[1];
	chn->PBendC = p[2];
	chn->FrqOfs += 3;
	goto transpose;

testnewsustain:
	if (val != 0xE8) goto testnewvib;
	chn->FrqSus = p[1];
	chn->FrqOfs += 2;
	goto testsustain;

testnewvib:
	if (val != 0xE3) goto transpose;
	chn->FrqOfs += 3;
	chn->VibSpd = p[1];
	chn->VibAmp = p[2];

transpose:
	p = chn->FrqPtr + chn->FrqOfs;
	chn->FreqTR = p[0];
	chn->FrqOfs++;



//<<<<<<<<<<<<<<<<<<<<<<<<<<
// VOLUME EFFECTS
//<<<<<<<<<<<<<<<<<<<<<<<<<<
VOLUfx:
	if (!chn->VolSus) goto volsustzero;
	chn->VolSus--;
	goto calcperiod;

volsustzero:
	if (chn->VBendC) goto do_VOLbend;
	if (--(chn->VolTcnt)) goto calcperiod;
	chn->VolTcnt = chn->VolTspd;

volu_cmd:
	p = chn->VolPtr + chn->VolOfs;
	val = p[0];

//testvoluend:
	if (val == 0xE1) goto calcperiod;		// VolSeq END
	if (val != 0xEA) goto testVOLsustain;	// VolSeq NEWBEND
	chn->VBendS = p[1];
	chn->VBendC = p[2];
	chn->VolOfs += 3;
	goto do_VOLbend;

testVOLsustain:
	if (val != 0xE8) goto testVOLloop;		// VolSeq SUSTAIN
	chn->VolSus = p[1];
	chn->VolOfs += 2;
	goto calcperiod;

testVOLloop:
	if (val != 0xE0) goto setvolume;		// VolSeq LOOP
	chn->VolOfs = (p[1] & 0x3F) - 5;
	goto volu_cmd;

do_VOLbend:
	chn->VBendX ^= 0xFF;				// DO VOLBend
	if (!chn->VBendX) goto calcperiod;
	chn->VBendC--;
	chn->Volume += chn->VBendS;

	if (!(chn->VBendS & 0x80)) goto calcperiod;
	chn->Volume = chn->VBendC = 0;
	goto calcperiod;

setvolume:
	chn->Volume = p[0];
	chn->VolOfs++;



//<<<<<<<<<<<<<<<<<<<<<<<<<<
// CALCULATE PERIOD
//<<<<<<<<<<<<<<<<<<<<<<<<<<
calcperiod:

	tmp = chn->FreqTR;
	if (tmp < 0) goto lockednote;// is < 0? -> locked note

	tmp += chn->Note;			// +Note
	tmp += chn->NoteTR;			// +NoteTR

lockednote:
	tmp &= 0x7F;				// use only lower 7bit
	TabOffset = (tmp * 2);		// (TABOFS OF NOTE*2)
	Period = PERIODS[tmp];

	chn->PER1 = Period;			// DEBUG



//<<<<<<<<<<<<<<<<<<<<<<<<<<
// VIBRATOR
//<<<<<<<<<<<<<<<<<<<<<<<<<<


    // Vibrato.
    //
    // Vibrato offset changes between [0,1,...,2*vibAmpl]
    // Offset minus vibAmpl is value to apply.
    
    if (chn->VibDel == 0)
    {
        SWORD vibDelta = chn->VibAmp;
        vibDelta <<= 1;  // pos/neg amplitude delta
    
        // vibFlag bit 5: 0 => vibrato down, 1 => vibrato up
        //
        // (NOTE) In the original player code the vibrato half speed delay
        // flag (D6) in bit 0 is toggled but never checked, because the
        // vibrato flag byte will never get negative.
    
        tmp1 = chn->VibAmpC;

        if ((chn->VibXOR&(1<<5))==0)
        {
            tmp1 -= chn->VibSpd;
            // Lowest value reached?
            if (tmp1 < 0)
            {
                tmp1 = 0;
                chn->VibXOR |= (1<<5);   // switch to vibrato up
            }
        }
        else
        {
            tmp1 += chn->VibSpd;
            // Amplitude reached?
            if (tmp1 > vibDelta)
            {
                tmp1 = (SBYTE)vibDelta;
                chn->VibXOR &= ~(1<<5);  // switch to vibrato down
            }
        }

        chn->VibAmpC = tmp1;
    
        // noteTableOffset is note*2;
    
        tmp1 -= chn->VibAmp;

        // Octave 5 at period table byte-offset 96 contains the highest
        // period only. 96+160 = 256. This next bit ensures that vibrato
        // does not exceed the five octaves in the period table.
        // Octave 6 (but lowest!) is FC14 only.
        TabOffset += 160;  // + $a0
        while (TabOffset < 256)
        {
            tmp1 <<= 1;    // double vibrato value for each octave
            TabOffset += 2*12;  // advance octave index
        };
        Period += tmp1;  // apply vibrato to period
    
        // (NOTE) Questionable code here in the original player sources.
        // Although bit 0 of D6 is toggled, the code (see above) that
        // checks it is unreachable.
    }
    else
    {
        --chn->VibDel;
    
        // (NOTE) Questionable code here in existing FC players. Although
        // bit 0 of D6 is toggled, the code that checks it is unreachable.
        // That bad code has not been converted.
    }


/*
	__asm
	{
    	pushad
		mov	 edi,chn
		xor	 ecx,ecx

		mov	 ebx,TabOffset			// BX = d5 = TabOffset (idx*2)
		mov	 cl,[edi]STR_ASMPREFIX.VibXOR		// CL = d7 = VibXORval
		cmp	 [edi]STR_ASMPREFIX.VibDel,0
		jz	 vibrator
		dec	 [edi]STR_ASMPREFIX.VibDel
		jmp	 novibrato
vibrator:
		xor	 edx,edx
		mov	 ch,[edi]STR_ASMPREFIX.VibAmp
		add	 ch,ch					// CH = d4 = VibAmp * 2
		mov	 dl,[edi]STR_ASMPREFIX.VibAmpC 	// DL = d1 = VibAmpCounter
		test cl,80h
		jz	 vib1
		test cl,1
		jnz	 vib4
vib1:
		test cl,20h
		jnz	 vib2
		sub	 dl,[edi]STR_ASMPREFIX.VibSpd
		jnc	 vib3
		or	 cl,20h
		xor	 edx,edx
		jmp	 vib3
vib2:
		add	 dl,[edi]STR_ASMPREFIX.VibSpd
		cmp	 dl,ch
		jc	 vib3
		and	 cl,0DFh
		mov	 dl,ch
vib3:
		mov	 [edi]STR_ASMPREFIX.VibAmpC,dl
vib4:
		shr  ch,1
		sub	 dl,ch
		jnc	 vib5
		sub	 dx,0100h
vib5:
		add	 bl,0A0h
		jc	 vib7
vib6:
		add	 dx,dx
		add	 bl,018h
		jnc	 vib6
vib7:
		add  Period,dx
novibrato:
		xor	 cl,1
		mov	 [edi]STR_ASMPREFIX.VibXOR,cl
        popad
	}
*/


//<<<<<<<<<<<<<<<<<<<<<<<<<<
// PORTAMENTO
//<<<<<<<<<<<<<<<<<<<<<<<<<<
	chn->PortaX = (chn->PortaX + 1) & 1;
	if (chn->PortaX || FC13mode)
	{
		SBYTE param = chn->PortaV;
		if (param != 0)
		{
            if (param > 0x1f)  // > 0x20 = portamento down
            {
                param &= 0x1f;
                param = (-param);
            }
            chn->Period -= param;
		}
	}


//<<<<<<<<<<<<<<<<<<<<<<<<<<
// PITCH BEND
//<<<<<<<<<<<<<<<<<<<<<<<<<<

	chn->PBendX = (chn->PBendX + 1) & 1;
	if (chn->PBendX)
	{
		if (chn->PBendC)
		{
			chn->PBendC--;
			SBYTE speed = chn->PBend;

			if (speed) chn->Period -= speed;
		}
	}

//<<<<<<<<<<<<<<<<<<<<<<<<<<
// CHECK LIMITS
//<<<<<<<<<<<<<<<<<<<<<<<<<<

		Period += chn->Period;
		if (Period <= 0x0070) Period = 0x0071;
		if (Period >  0x0d60) Period = 0x0d60;

		paulaSetPeriod(VocNum, Period);
		paulaSetVolume(VocNum, chn->Volume);

		chn->PER2 = Period;			// DEBUG
}















/*----------------------------------------------------------------------*/
int		FCp_Update(void)
/*----------------------------------------------------------------------*/
{
		if ((Opened == FALSE) || (Playing == FALSE)) return 1;

		if (--REPcnt) goto noNewNote;

		REPcnt = REPspd;	// Restore replayspeed counter

		SEQnext = 4;

		NewNote(0);
		NewNote(1);
		NewNote(2);
		NewNote(3);

noNewNote:
		Effects(0);
		Effects(1);
		Effects(2);
		Effects(3);

		return 0;
}
